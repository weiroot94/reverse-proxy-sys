/*
 * This source file was generated by the Gradle 'init' task
 */
package com.example.SlaveNode;

import io.netty.bootstrap.Bootstrap;
import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.SimpleChannelInboundHandler;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioSocketChannel;

import java.util.logging.Logger;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class App {
    private static final Logger logger = Logger.getLogger(App.class.getName());
    private static final ExecutorService executor = Executors.newCachedThreadPool();
    private static final byte MAGIC_FLAG = (byte) 0x05; // Example MAGIC_FLAG value


    public static void main(String[] args) throws InterruptedException {
        String fulladdr = "188.245.104.81:8000";
        NioEventLoopGroup group = new NioEventLoopGroup();

        String[] parts = fulladdr.split(":");
        String host = parts[0];
        int port = Integer.parseInt(parts[1]);

        // Create a Netty client to connect to the remote server
        Bootstrap bootstrap = new Bootstrap();
        bootstrap.group(new NioEventLoopGroup()) // Use an appropriate event loop group
                .channel(NioSocketChannel.class)
                .handler(new ChannelInitializer<SocketChannel>() {
                    @Override
                    protected void initChannel(SocketChannel ch) throws Exception {
                        ChannelPipeline p = ch.pipeline();
                       // p.addLast(new ByteArrayDecoder());
                       // p.addLast(new ByteArrayEncoder());
                        p.addLast(new ByteInboundHandler(host, port, group)); // Add your Socks5ServerHandler
                    }
                });

        ChannelFuture future = bootstrap.connect(host, port);
        future.addListener(f -> {
            if (f.isSuccess()) {
                System.out.println("Connected to " + fulladdr);
            } else {
                System.err.println("Connection failed");
            }
        });
        
        future.channel().closeFuture().sync(); // Block until the channel is closed
    }
}

// Custom handler to receive one byte and trigger a new connection
class ByteInboundHandler extends SimpleChannelInboundHandler<ByteBuf> {

    private final String host;
    private final int port;
    private final NioEventLoopGroup group;

    public ByteInboundHandler(String host, int port, NioEventLoopGroup group) {
        this.host = host;
        this.port = port;
        this.group = group;
    }

    @Override
    protected void channelRead0(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
        if (in.readableBytes() >= 1) {
            byte receivedByte = in.readByte();
            System.out.println("Received byte: " + receivedByte);
               
            if(receivedByte == 55){
                // Start a new connection using a new channel
                NioEventLoopGroup newGroup = new NioEventLoopGroup();
                Bootstrap bootstrap2 = new Bootstrap();
                bootstrap2.group(newGroup)
                        .channel(NioSocketChannel.class)
                        .handler(new ChannelInitializer<SocketChannel>() {
                            @Override
                            protected void initChannel(SocketChannel ch) throws Exception {
                                ChannelPipeline p = ch.pipeline();
                                p.addLast(new Socks5Server.Socks5ServerHandler()); // Handle data from this new connection
                            }
                        });

                ChannelFuture future2 = bootstrap2.connect(host, port);
                future2.addListener(f -> {
                    if (f.isSuccess()) {
                        System.out.println("Connected to " + host + ":" + port + " (Secondary Channel)");
                    } else {
                        System.err.println("Connection failed (Secondary Channel)");
                    }
                });

                // Optionally, block until the new channel is closed
                //future2.channel().closeFuture().sync();
                future2.channel().closeFuture().addListener(closeFuture -> newGroup.shutdownGracefully());
            }
        }
    }
}
